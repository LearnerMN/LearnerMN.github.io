<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Рекуррент харьцаа ба матриц by LearnerMN</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Рекуррент харьцаа ба матриц</h1>
      <h2 class="project-tagline">Алгоритм, Математик, Программ</h2>
    </section>

    <section class="main-content">
      <h1>
<a id="Рекуррент-харьцаа-ба-матриц" class="anchor" href="#%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%80%D0%B5%D0%BD%D1%82-%D1%85%D0%B0%D1%80%D1%8C%D1%86%D0%B0%D0%B0-%D0%B1%D0%B0-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Рекуррент харьцаа ба матриц</h1>

<p>Рекуррент харьцаагаар өгөгдсөн шугаман тэгшитгэлийг/ <code>F(n) = A*F(n-1) + B*F(n-2)</code> / бид нар бодохдоо динамик програмчлалын арга ашиглаж боддог. </p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">int</span> <span class="pl-en">F</span>(<span class="pl-k">int</span> A,<span class="pl-k">int</span> B, <span class="pl-k">int</span> N){
    vector&lt; <span class="pl-k">int</span> &gt; F[N+<span class="pl-c1">1</span>];
    F[<span class="pl-c1">1</span>] = <span class="pl-c1">1</span>;
    F[<span class="pl-c1">2</span>] = <span class="pl-c1">2</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i=<span class="pl-c1">3</span>; i&lt;=N;){
        F[i] = A*F[i-<span class="pl-c1">1</span>] + B*F[i-<span class="pl-c1">2</span>];
    }
    <span class="pl-k">return</span> F[N];
}</pre></div>

<p>Энэ нь <code>N</code>-р гишүүнийг олоход <code>O(N)</code> хугацаа зарцуулдаг. Гэвч зарим тохиолдолд бид <code>LogN</code>-р бодох шаардлага гарч ирдэг.</p>

<p>Бид нар шугаман рекуррент тэгшитгэлийг <code>X(i+1) = M X(i)</code> хэлбэртэй бичиж болно. Үүнд:
<code>X(i+1)</code> болон <code>X(i)</code> нь <code>1 x K</code> хэмжээтэй матриц. <code>M</code> нь <code>K x K</code>хэмжээтэй матриц.</p>

<pre><code>| f(n+1)   |       | f(n)   |
|  f(n)    |       | f(n-1) |
| f(n-1)   | = M x | f(n-2) |
| ......   |       | ...... |
| f(n-k+1) |       | f(n-k) |
</code></pre>

<p>Эндээс бид нар рекуррент харьцаагаа ашиглаад <code>M</code> матрицаа олно.</p>

<ol>
<li>Хамгийн энгийн рекуррент харьцаа болох Фиббоначийн дараалалыг авч үзье.</li>
</ol>

<pre><code>f(n) = f(n-1) + f(n-2) =&gt; f(n+1) = f(n) + f(n-1)
</code></pre>

<p>Тэгвэл X(i+1) болон X(i) матрицууд дараах байдлаар бичигдэнэ.</p>

<pre><code>| f(n+1) | = M x | f(n)   | =&gt; | f(n+1) | = | a b | x | f(n)   |
| f(n)   |       | f(n-1) |    | f(n)   |   | c d |   | f(n-1) |
</code></pre>

<p>Эндээс харахад бидний <code>K</code> тоо буюу матрицын хэмжээ нь тухайн харьцаа өөрөөсөө өмнөх хэдэн гишүүнээсээ хамааралтай байна гэдгээс олно. Фиббаночийн хувьд өмнөх 2 гишүүнээсээ хамаардаг тул матрицын хэмжээ <code>K=2</code>.
Одоо <code>М</code> матрицыг олъё. Дээрх <code>M</code> болон <code>X(i-1)</code> матрицыг үржвэл:</p>

<pre><code>a*f(n) + b*f(n-1) = f(n+1) 
c*f(n) + d*f(n-1) = f(n)
</code></pre>

<p>Дарааллыхаа эхний 3-н гишүүнийг мэдэх учир орлуулаад бодохоор a=1, b=1, c=1, d=0 гэж гарна. 
Одоо бид М-г мэдэх учраас дараах байдлаар бичиж болно.</p>

<pre><code>| f(n+1) | = | 1 1 | x | f(n)   |
| f(n)   |   | 1 0 |   | f(n-1) |
</code></pre>

<pre><code>| ? | = | 1 1 | x | 8 |
| 8 |   | 1 0 |   | 5 |
</code></pre>

<p>? =&gt; 8<em>1 + 5</em>1 = 13 </p>

<h3>
<a id="Матриц-үүсгэх" class="anchor" href="#%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86-%D2%AF%D2%AF%D1%81%D0%B3%D1%8D%D1%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Матриц үүсгэх</h3>

<p><img src="http://i.imgur.com/iQ802FF.png"></p>

<h3>
<a id="Анализ" class="anchor" href="#%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Анализ</h3>

<p>Дараах рекуррентийн хувьд авч үзье: <code>f(n) = f(n-1) + f(n-2)</code>.</p>

<pre><code>M x |  f(n)  | = | f(n+1) |
    | f(n-1) |   |  f(n)  |
</code></pre>

<p>Тэгшитгэлийн 2 талыг <code>M</code>-р үржье</p>

<pre><code>M x M x |  f(n)  | = M x | f(n+1) | = | f(n+2) |
        | f(n-1) |       |  f(n)  |   | f(n+1) |
</code></pre>

<p>Эмхэтгэвэл:</p>

<pre><code>M^2 x |  f(n)  | = | f(n+2) |
      | f(n-1) |   | f(n+1) |
</code></pre>

<p>Дараах байдалтай болох нь харагдаж байна.</p>

<pre><code>M^3 x |  f(n)  | = | f(n+3) |
      | f(n-1) |   | f(n+2) |
</code></pre>

<pre><code>M^4 x |  f(n)  | = | f(n+4) |
      | f(n-1) |   | f(n+3) |

...............................
...............................
...............................

M^k x |  f(n)  | = | f(n+k) |
      | f(n-1) |   |f(n+k-1)|
</code></pre>

<h3>
<a id="Матрицын-c-хэл-дээрх-код" class="anchor" href="#%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%8B%D0%BD-c-%D1%85%D1%8D%D0%BB-%D0%B4%D1%8D%D1%8D%D1%80%D1%85-%D0%BA%D0%BE%D0%B4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Матрицын C++ хэл дээрх код</h3>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> MOD = <span class="pl-c1">1000000007</span>;
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span><span class="pl-k">;</span>
<span class="pl-c">// Matrix class</span>
<span class="pl-k">class</span> <span class="pl-en">Matrix</span>{
    <span class="pl-k">public:</span>
        <span class="pl-k">int</span> N; <span class="pl-c">// Matrix size</span>
        vector&lt; vector&lt; <span class="pl-k">long</span> <span class="pl-k">long</span> &gt; &gt; data; <span class="pl-c">// matrix values</span>

        <span class="pl-en">Matrix</span>(<span class="pl-k">int</span> N); <span class="pl-c">// constructor resize N matrix</span>
        <span class="pl-en">Matrix</span>(<span class="pl-k">const</span> Matrix &amp;matrix); <span class="pl-c">// constructor assign matrix values</span>

        <span class="pl-k">const</span> Matrix &amp;<span class="pl-k">operator</span>=(<span class="pl-k">const</span> Matrix &amp;A); <span class="pl-c">// assign operator</span>
        <span class="pl-k">const</span> Matrix <span class="pl-k">operator</span>*(<span class="pl-k">const</span> Matrix &amp;A); <span class="pl-c">// product operator</span>
        <span class="pl-k">const</span> Matrix <span class="pl-k">operator</span>^(<span class="pl-k">int</span> P ); <span class="pl-c">// pow operator</span>

        <span class="pl-en">~Matrix</span>(); 
};

<span class="pl-en">Matrix::Matrix</span>(<span class="pl-k">int</span> N){
    <span class="pl-v">this</span>-&gt;N = N;
    data = vector&lt; vector&lt; <span class="pl-k">long</span> <span class="pl-k">long</span> &gt; &gt;(N, vector&lt; <span class="pl-k">long</span> <span class="pl-k">long</span> &gt;(N));
}

<span class="pl-en">Matrix::Matrix</span>(<span class="pl-k">const</span> Matrix &amp;A){
    <span class="pl-v">this</span>-&gt;N = A.<span class="pl-smi">N</span>;
    data = vector&lt; vector&lt; <span class="pl-k">long</span> <span class="pl-k">long</span> &gt; &gt;(A.<span class="pl-smi">data</span>);
}
<span class="pl-en">Matrix::~Matrix</span>(){
    data.<span class="pl-c1">clear</span>();
}

<span class="pl-k">const</span> Matrix &amp;Matrix::<span class="pl-k">operator</span>=(<span class="pl-k">const</span> Matrix &amp;A){
    <span class="pl-k">if</span>( &amp;A != <span class="pl-v">this</span> ){
        data.<span class="pl-c1">clear</span>();
        N = A.<span class="pl-smi">N</span>;
        data = vector&lt; vector&lt; <span class="pl-k">long</span> <span class="pl-k">long</span> &gt; &gt;(A.<span class="pl-smi">data</span>);
    }
    <span class="pl-k">return</span> *<span class="pl-v">this</span>;
}
<span class="pl-k">const</span> Matrix Matrix::<span class="pl-k">operator</span>*(<span class="pl-k">const</span> Matrix &amp;A){
    Matrix <span class="pl-smi">C</span>(A.<span class="pl-smi">N</span>);
    <span class="pl-k">for</span>( <span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; A.<span class="pl-smi">N</span>; ++i )
        <span class="pl-k">for</span>( <span class="pl-k">int</span> j = <span class="pl-c1">0</span>; j &lt; A.<span class="pl-smi">N</span>; ++j ){
            <span class="pl-k">for</span>( <span class="pl-k">int</span> k = <span class="pl-c1">0</span>; k &lt; A.<span class="pl-smi">N</span>; ++k )
                C.<span class="pl-smi">data</span>[i][j] = (C.<span class="pl-smi">data</span>[i][j] + data[i][k] * A.<span class="pl-smi">data</span>[k][j])%MOD;
        }
    <span class="pl-k">return</span> C;
}

<span class="pl-k">const</span> Matrix Matrix::<span class="pl-k">operator</span>^(<span class="pl-k">int</span> P){
    <span class="pl-k">if</span>(P == <span class="pl-c1">1</span>) <span class="pl-k">return</span> (*<span class="pl-v">this</span>);
    <span class="pl-k">if</span>(P &amp; <span class="pl-c1">1</span>) <span class="pl-k">return</span> ((*<span class="pl-v">this</span>) * ((*<span class="pl-v">this</span>) ^ (P-<span class="pl-c1">1</span>)));
    Matrix B = ((*<span class="pl-v">this</span>) ^ (P/<span class="pl-c1">2</span>));
    <span class="pl-k">return</span> (B*B);
}

<span class="pl-k">long</span> <span class="pl-k">long</span> <span class="pl-en">value</span>(Matrix &amp;matrix,<span class="pl-k">int</span> P,vector&lt; <span class="pl-k">int</span> &gt; &amp;def){
    <span class="pl-k">if</span> (P &lt;= def.<span class="pl-c1">size</span>())
        <span class="pl-k">return</span> def[P-<span class="pl-c1">1</span>];
    Matrix res = matrix^(P-def.<span class="pl-c1">size</span>());
    <span class="pl-k">return</span> ((res.<span class="pl-smi">data</span>[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] * def[<span class="pl-c1">1</span>])%MOD + (res.<span class="pl-smi">data</span>[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] * def[<span class="pl-c1">0</span>])%MOD)%MOD;
}

<span class="pl-c">// main</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>(){

    vector&lt; <span class="pl-k">int</span> &gt; def = {<span class="pl-c1">4</span>,<span class="pl-c1">14</span>};

    Matrix <span class="pl-smi">matrix</span>(<span class="pl-c1">2</span>);
    matrix.<span class="pl-smi">data</span>[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] = <span class="pl-c1">3</span>; matrix.<span class="pl-smi">data</span>[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] = <span class="pl-c1">2</span>;
    matrix.<span class="pl-smi">data</span>[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>] = <span class="pl-c1">1</span>; matrix.<span class="pl-smi">data</span>[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>] = <span class="pl-c1">0</span>;

    <span class="pl-k">int</span> t;
    cin&gt;&gt;t;
    <span class="pl-k">while</span> (t--){
        <span class="pl-k">int</span> n;
        cin&gt;&gt;n;
        cout&lt;&lt;<span class="pl-c1">value</span>(matrix,n,def)&lt;&lt;endl;
    }

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<h3>
<a id="Бие-дааж-бодох-бодлогууд" class="anchor" href="#%D0%91%D0%B8%D0%B5-%D0%B4%D0%B0%D0%B0%D0%B6-%D0%B1%D0%BE%D0%B4%D0%BE%D1%85-%D0%B1%D0%BE%D0%B4%D0%BB%D0%BE%D0%B3%D1%83%D1%83%D0%B4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Бие дааж бодох бодлогууд</h3>

<ol>
<li>
<a href="http://www.spoj.com/CSMS/problems/MSR10_04/"> Үг </a><br>
</li>
<li>
<a href="http://www.spoj.com/CSMS/problems/TSEREG/"> Цэрэг </a><br>
</li>
<li>
<a href="https://uva.onlinejudge.org/external/108/p10870.pdf"> UVa 10870 : Recurrences </a><br>
</li>
<li>
<a href="https://uva.onlinejudge.org/external/115/p11551.pdf"> UVa 11551 : Experienced Endeavour </a><br>
</li>
<li><a href="http://www.spoj.com/CSMS/problems/NEIGH/"> Хөршүүд </a></li>
</ol>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
